\tableofcontents
\pagebreak
\section*{Постановка задачи}
\addcontentsline{toc}{section}{Постановка задачи}
Реализовать распределенную систему по асинхронной обработке запросов. В данной
распределенной системе должно существовать 2 вида узлов: «управляющий» и
«вычислительный». Необходимо объединить данные узлы в соответствии с той топологией,
которая определена вариантом. Связь между узлами необходимо осуществить при помощи
технологии очередей сообщений. Также в данной системе необходимо предусмотреть проверку
доступности узлов в соответствии с вариантом. При убийстве («kill -9») любого вычислительного
узла система должна пытаться максимально сохранять свою работоспособность, а именно все
дочерние узлы убитого узла могут стать недоступными, но родительские узлы должны сохранить
свою работоспособность.
Управляющий узел отвечает за ввод команд от пользователя и отправку этих команд на
вычислительные узлы. \\ Топология - бинарное дерево поиска. \\ Список основных поддерживаемых команд:
\begin{itemize}
    \item create id - создать новый вычислительный узел с указанным id
    \item remove id - удалить вычислительный узел с указанным id и её дочерние узлы.
    \item exec id text pattern - поиск подстроки в строке вычислительным узлом с указанным id 
    \item ping id - проверка доступности вычислительного узла с указанным id.
\end{itemize}

\section*{Цель работы}
\addcontentsline{toc}{section}{Цель работы}
Приобритение практических навыков в:
\begin{itemize}
    \item Управлении серверами сообщений (№6)
    \item Применение отложенных вычислений (№7)
    \item Интеграция программных систем друг с другом (№8)
\end{itemize}

\section*{Алгоритм решения}
\addcontentsline{toc}{section}{Алгоритм решения}
Имеем два исполняемых файла \textbf{server} и \textbf{client}, но работаем только с одним \textbf{server}, а другой используется внутри вызова execl для создания вычислительного узла. Вычислительный узел создается, когда пользователь вводит команду \textit{create id}, если узел с указанным id существует, то он не создается, проверка существования узла производится с помошью поиска в бинарном дереве поиска. После этого есть доступный узел, к которому можно обратиться с помощью команд \textit{exec id text pattern} и \textit{ping id}. \textit{ping id} - проверяет доступность узла, путем передачи сообщения, содержащего тип сообщения и id нужной ноды,  когда сообщение дойдет до нужного узла, узел отправит обратно сообщение управляющей ноде, тем самым сообщив, что он доступен. \textit{exec id text pattern}, выполняется подобным же образом, только теперь сообщение еще содержит строку и подстроку. В ответ отправляются начальные позиции совпадений. \textit{remove id} работает следующем образом: ищется данный узел и его дочерние узлы, дальше всем этим нодам отправляется о сообщение об удалении, перед завершение работы, они закрывают сокеты, с помощью которых осуществляется передача сообщений, после этого заверщает работу.      
\pagebreak
\section*{Код программы}
\addcontentsline{toc}{section}{Код программы}
\subsection*{Заголовчный файл message.h для сообщений}
\lstinputlisting{code/message.h}
\subsection*{Заголовчный файл ZMQUtils.h с настройками сокетов}
\lstinputlisting{code/ZMQUtils.h}
\subsection*{Файл message.cpp с реализацией функций для создания сообщений}
\lstinputlisting{code/message.cpp}
\subsection*{Файл ZMQUtils.cpp с реализацикй функция для настройки сокетов}
\lstinputlisting{code/ZMQUtils.cpp}
\subsection*{Файл Tree.h содержит реализацию бинарного дерева поиска}
\lstinputlisting{code/Tree.h}
\subsection*{Файл server.cpp}
\lstinputlisting{code/server.cpp}
\subsection*{Файл client.cpp}
\lstinputlisting{code/client.cpp}
\pagebreak

\section*{Тест кейсы}
\addcontentsline{toc}{section}{Тест кейсы}

\begin{alltt}
create 3
OK: 12963
create 5
OK: 12969
create 7
OK: 12972
ping 5
OK: 1
ping 3
OK: 1
ping 13
Error: Not found
exec 5 abbaba ab
OK:5: [0; 3]
exec 5 ccc c
OK:5: [0; 1; 2]
remove 5
OK
ping 5
Error: Not found

\end{alltt}

\newpage

\section*{Вывод}
\addcontentsline{toc}{section}{Вывод}

 Данная лабораторная работа была направлена на изучение технологии очереди сообщений, на основое которой необходимо было построить сеть с заданной топологией. В ходе выполнения лабороторной работе, оказалось, что работать с очередью сообщений \textbf{ZMQ} так же удобно как с \textbf{pipe} и \textbf{shared memory}. Навыки, приобретенные в данной лабораторной работе, являются очень полезными, так как во многих проектах используется очередь сообщений. 
